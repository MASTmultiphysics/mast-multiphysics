/*
* This example solves a cantilever rectangular plate with a uniformly distributed load on the top of the plate.
*     For direct solver, run with options: -ksp_type preonly -pc_type lu
*/

// C/C++ includes.
#include <iostream>

// libMesh includes.
#include <libmesh/libmesh.h>
#include <libmesh/replicated_mesh.h>
#include <libmesh/mesh_generation.h>
#include <libmesh/equation_systems.h>
#include <libmesh/fe_type.h>
#include <libmesh/numeric_vector.h>
#include <libmesh/exodusII_io.h>

// MAST includes.
#include "base/nonlinear_system.h"
#include "elasticity/structural_system_initialization.h"
#include "base/physics_discipline_base.h"
#include "boundary_condition/dirichlet_boundary_condition.h"
#include "base/parameter.h"
#include "base/constant_field_function.h"
#include "property_cards/isotropic_material_property_card.h"
#include "property_cards/solid_2d_section_element_property_card.h"
#include "base/nonlinear_implicit_assembly.h"
#include "elasticity/structural_nonlinear_assembly.h"


int main(int argc, const char** argv)
{
    // Initialize libMesh library.
    libMesh::LibMeshInit init(argc, argv);

    // Create Mesh object on default MPI communicator and generate a 2D mesh of QUAD4 elements. We discretize with
    // 12 elements in the x-direction (0.0 to 36.0 inches) and 40 elements in the y-direction (0.0 to 120.0 inches).
    //   Note that in libMesh, all meshes are parallel by default in the sense that the equations on the mesh are
    //   solved in parallel by PETSc. A "ReplicatedMesh" is one where all MPI processes have the full mesh in memory,
    //   as compared to a "DistributedMesh" where the mesh is "chunked" up and distributed across processes, each
    //   having their own piece.
    libMesh::ReplicatedMesh mesh(init.comm());
    libMesh::MeshTools::Generation::build_square(mesh, 12, 40, 0.0, 36.0, 0.0, 120.0, libMesh::QUAD4);
    mesh.print_info();
    // mesh.boundary_info->print_info();
    // mesh.write("ex3_plate_structural_mesh.exo");

    // For later reference, the boundary and subdomain ID's generated by the libMesh mesh generation are sketched below.
    //
    //        y               (#) Boundary ID
    //        | (2)           [#] Subdomain ID
    //  120.0 O-----O
    //        |     |          x - right
    //        |     |          y - up
    //    (3) | [0] | (1)      z - out of screen
    //        |     |
    //        |     |
    //    0.0 O-----O--x
    //          (0)
    //       0.0   36.0

    // Create EquationSystems object, which is a container for multiple systems of equations that are
    // defined on a given mesh.
    libMesh::EquationSystems equation_systems(mesh);

    // Add system of type MAST::NonlinearSystem (which wraps libMesh::NonlinearImplicitSystem) to the
    // EquationSystems container.
    //   We name the system "structural" and also get a reference to the system so we can easily reference it later.
    MAST::NonlinearSystem & system = equation_systems.add_system<MAST::NonlinearSystem>("structural");

    // Create a finite element type for the system. Here we use first order Lagrangian-type finite elements.
    libMesh::FEType fetype(libMesh::FIRST, libMesh::LAGRANGE);

    // Initialize the system to the correct set of variables for a structural analysis. In libMesh this is analogous
    // to adding variables (each with specific finite element type/order to the system for a particular system
    // of equations.
    MAST::StructuralSystemInitialization structural_system(system,
                                                           system.name(),
                                                           fetype);

    // Initialize a new structural discipline using equation_systems.
    MAST::PhysicsDisciplineBase discipline(equation_systems);

    // Create and add boundary conditions to the structural system. A Dirichlet BC adds fixed displacement BCs. Here we
    // use the side boundary ID numbering created by the libMesh generator to clamp the edge of the mesh along x=0.0.
    // We apply the BC to all variables on each node in the subdomain ID 0, which clamps this edge.
    MAST::DirichletBoundaryCondition clamped_edge;    // Create BC object.
    clamped_edge.init(0, structural_system.vars());   // Assign boundary ID and variables to constrain
    discipline.add_dirichlet_bc(0, clamped_edge);     // Attach boundary condition to discipline
    discipline.init_system_dirichlet_bc(system);      // Initialize the BC in the system.

    // Initialize the equation system since we now know the size of our system matrices (based on mesh, element type,
    // variables in the structural_system) as well as the setup of dirichlet boundary conditions. This initialization
    // process is basically a pre-processing step to preallocate storage and spread it across processors.
    equation_systems.init();
    equation_systems.print_info();

    // Create parameters.
    MAST::Parameter thickness("th", 3.5);
    MAST::Parameter E("E", 10.0e6);
    MAST::Parameter nu("nu", 0.33);
    MAST::Parameter rho("rho", 0.1*0.00259);
    MAST::Parameter kappa("kappa", 5./6.);
    MAST::Parameter zero("zero", 0.0);
    MAST::Parameter pressure("p", 10.0);

    // Create ConstantFieldFunctions used to spread parameters throughout the model.
    MAST::ConstantFieldFunction th_f("h", thickness);
    MAST::ConstantFieldFunction E_f("E", E);
    MAST::ConstantFieldFunction nu_f("nu", nu);
    MAST::ConstantFieldFunction rho_f("rho", rho);
    MAST::ConstantFieldFunction kappa_f("kappa", kappa);
    MAST::ConstantFieldFunction off_f("off", zero);
    MAST::ConstantFieldFunction pressure_f("pressure", pressure);

    // Initialize load.
    MAST::BoundaryConditionBase surface_pressure(MAST::SURFACE_PRESSURE);
    surface_pressure.add(pressure_f);
    discipline.add_volume_load(0, surface_pressure);

    // Create the material property card ("card" is NASTRAN lingo) and the relevant parameters to it. An isotropic
    // material needs elastic modulus (E) and Poisson ratio (nu) to describe its behavior.
    MAST::IsotropicMaterialPropertyCard material;
    material.add(E_f);
    material.add(nu_f);
    material.add(kappa_f);
    material.add(rho_f);

    // Create the section property card. Attach all property values.
    MAST::Solid2DSectionElementPropertyCard section;
    section.add(th_f);
    section.add(off_f);

    // Attach material to the card.
    section.set_material(material);

    // Initialize the specify the subdomain in the mesh that it applies to.
    discipline.set_property_for_subdomain(0, section);

    // Create nonlinear assembly object and set the discipline and
    // structural_system. Create reference to system.
    MAST::NonlinearImplicitAssembly assembly;
    MAST::StructuralNonlinearAssemblyElemOperations elem_ops;
    assembly.set_discipline_and_system(discipline, structural_system);
    elem_ops.set_discipline_and_system(discipline, structural_system);
    MAST::NonlinearSystem& nonlinear_system = assembly.system();

    // Zero the solution before solving.
    nonlinear_system.solution->zero();

    // Solve the system and print displacement degrees-of-freedom to screen.
    nonlinear_system.solve(elem_ops, assembly);
    // nonlinear_system.solution->print_global();

    // Write output to Exodus.
    libMesh::ExodusII_IO exodus_io(mesh);
    exodus_io.write_equation_systems("ex3_plate_static.exo", equation_systems);

    return 0;
}